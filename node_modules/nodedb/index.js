var md5 = require('./libs/md5');

var fs = require('fs');

var uriManager = require('./libs/uriManager');

var nodedb = {};

nodedb.version = '0.0.1';


nodedb.savePath = null;

nodedb.init = function (config) {

  nodedb.savePath = fs.realpathSync(config.path ? config.path : '.');
  fs.exists(nodedb.savePath + '/_indexs', function (e, r) {
    if (!e)fs.mkdirSync(nodedb.savePath + '/_indexs');
  })

  return nodedb;
};

nodedb.get = function (uri, cb) {
  var path = nodedb.route(uri);
  var user_hash = nodedb._userHash(path.shift());
  fs.readFile(nodedb.savePath + '/' + user_hash, function (e, r) {
    if (e) {
      cb(404, null);
    } else {
      var result = {};
      try {
        var tree = JSON.parse(r.toString());
        result = tree;
        while (path.length) {
          result = result[path.shift()];
        }
      } catch (ex) {
        result = null;
      }
      cb(null, result);
    }
  });
};

/**
 *
 * @param string
 * @param cb
 */
nodedb.query = function (string, cb) {
  var v_hash = md5(string);
  if(fs.existsSync(nodedb.savePath+'/_indexs/'+v_hash)) {
    fs.readdir(nodedb.savePath + '/_indexs/' + v_hash, function (e, r) {
      if (e) {
        cb(e, r);
      } else {
        if (r.length) {
          var result = [];
          for (var i = 0; i < r.length; i++) {
            result.push({
              'uid':r[i].split(':')[1],
              'data':JSON.parse(fs.readFileSync(nodedb.savePath + '/' + r[i]))
            });
          }
          cb(null, result);
        } else {
          cb(null, []);
        }
      }
    });
  }else{
    cb(null, []);
  }
};
/**
 *
 * @param uri
 * @param data
 * @param option 定义需要索引的键
 * @param cb
 */
nodedb.put = function (uri, data, indexs, cb) {
  if (typeof indexs == 'function') {
    cb = indexs;
  }
  var path = nodedb.route(uri);
  var user_hash = nodedb._userHash(path.shift())
  fs.readFile(nodedb.savePath + '/' + user_hash, function (e, r) {
    var tree = {};
    if (r) {
      try {
        tree = JSON.parse(r);
      } catch (ex) {
        console.log(ex);
      }
    }
    var tmpTree = tree;
    while (path.length) {
      var curNode = path.shift();
      if (tmpTree[curNode] == undefined) {
        tmpTree[curNode] = {};
      }
      if (path.length == 0) {
        tmpTree[curNode] = data;
      }
      tmpTree = tmpTree[curNode];
    }

    fs.writeFile(nodedb.savePath + '/' + user_hash, JSON.stringify(tree), function (e1, r1) {
      cb(e1, r1);
      // index
      if (typeof indexs == 'object' && indexs.length) {
        for (var k in indexs) {
          // 索引键对应的值必须存在 且 不是对象类型
          if (data[indexs[k]] != undefined && typeof data[indexs[k]] != 'object') {
            var v_hash = md5(data[indexs[k]] + '');
            if (!fs.existsSync(nodedb.savePath + '/_indexs/' + v_hash)) {
              fs.mkdirSync(nodedb.savePath + '/_indexs/' + v_hash);
            }
            if (!fs.existsSync(nodedb.savePath + '/_indexs/' + v_hash + '/' + user_hash)) {
              fs.writeFileSync(nodedb.savePath + '/_indexs/' + v_hash + '/' + user_hash, 'index');
            }
          }
        }
      }
    });
  });
};

nodedb.route = function (uri) {
  var nodes = nodedb._parse(uri);
  return nodes;
}

nodedb._parse = function (str) {
  return uriManager.object(str);
};

nodedb._read = function (user) {

};

nodedb._userHash = function (user) {
  return md5(user) + ':' + user;
};
/**
 * 将所有索引对象读出来，可以放在内存里，不过用户多了以后不推荐啊，窝真是傻，这样的function都写出来了
 */
nodedb.cache = function () {
  var indexs = nodedb.savePath + '/_indexs';
  return (function _cur_read(path) {
    var result = {};
    var child = fs.readdirSync(path);
    for (var k in child) {
      result[child[k]] = {};
      if (fs.statSync(path + '/' + child[k]).isDirectory()) {
        result[child[k]] = _cur_read(path + '/' + child[k]);
      }
    }
    return result;
  })(indexs);
};

module.exports = nodedb.init;

/**
 * Change Log
 * 1     init
 */

